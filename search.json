[{"title":"学会lambda表达式，写优雅代码","url":"/2018/09/14/lambda/","content":"### 什么是lambda\nlambda表达式是一段可以传递的代码，它的核心思想是将面向对象中的传递数据变成传递行为。回顾一下我们在使用java8之前要做的事，之前我们编写一个线程运行是这样的：\n\n```\nExecutorService cachedThreadPool = Executors.newCachedThreadPool();\ncachedThreadPool.execute(new Runnable() {\n  @Override\n  public void run() {\n    System.out.println(\"do something.\");\n  }\n});\n```\n\n那如果是lambda该怎么做?\n\n```\nExecutors.newCachedThreadPool().execute(() -> System.out.println(\"do something.\"));\n```\n\n这看起来很酷，我们可以用()和->的方式完成这件事。下面一起来学习一下lambda的语法。\n\n### 基础语法\n在lambda中我们遵循如下的表达式来编写：\n\n```\n(params) -> expression\n(params) -> statement\n(params) -> { statements }\n```\n\nlambda表达式可以包含多个参数,例如：\n\n```\nint sum = (x, y) -> x + y;\n```\n\n这时候我们应该思考这段代码不是之前的x和y数字相加，而是创建了一个函数，用来计算两个操作数的和。 后面用int类型进行接收，在lambda中为我们省去了return。这看起来很神奇，但同时有没有虚无飘渺的感觉？那么，下面我们来学习一下它背后的逻辑。\n\n### 函数式接口\n函数式接口是只有一个方法的接口，用作lambda表达式的类型。看看jdk中的Runnable源码\n\n```\n@FunctionalInterface\npublic interface Runnable {\n    /**\n     * When an object implementing interface <code>Runnable</code> is used\n     * to create a thread, starting the thread causes the object's\n     * <code>run</code> method to be called in that separately executing\n     * thread.\n     * <p>\n     * The general contract of the method <code>run</code> is that it may\n     * take any action whatsoever.\n     *\n     * @see     java.lang.Thread#run()\n     */\n    public abstract void run();\n}\n```\n\n这里只有一个抽象方法run， 同时也使用注解@FunctionalInterface告诉编译器这是一个函数式接口，标识后明确了这个函数中只有一个抽象方法，当你尝试在接口中编写多个方法的时候编译器将不允许这么干。\n\n函数式接口举例，具体可参见jdk的java.util.function包\n|接口|参数|返回值|类别|\n|----|----|----|----|\n|Consumer|T|void|消费型接口|\n|Supplier|None|T|供给型接口|\n|Function|T|R|函数型接口|\n|Predicate|T|Boolean|断言型接口|\n\n**1.消费型接口使用示例**\nConsumer接口源码\n\n```\n@FunctionalInterface\npublic interface Consumer<T> {\n\n    /**\n     * Performs this operation on the given argument.\n     *\n     * @param t the input argument\n     */\n    void accept(T t);\n\n    default Consumer<T> andThen(Consumer<? super T> after) {\n        Objects.requireNonNull(after);\n        return (T t) -> { accept(t); after.accept(t); };\n    }\n}\n```\n\n使用示例\n\n```\npublic static void donation(Integer money, Consumer<Integer> consumer){\n    consumer.accept(money);  \n}\npublic static void main(String[] args) {\n    donation(1000, money -> System.out.println(\"好心的麦乐迪为Blade捐赠了\"+money+\"元\")) ;\n}\n```\n\n`money -> System.out.println(\"好心的麦乐迪为Blade捐赠了\"+money+\"元\")`  实现Consumer接口的抽象函数\n`consumer.accept(money);` 调用Consumer接口的实现方法。\n\n**2.供给型接口示例**\nSupplier接口源码\n\n```\n@FunctionalInterface\npublic interface Supplier<T> {\n\n    /**\n     * Gets a result.\n     *\n     * @return a result\n     */\n    T get();\n}\n```\n\n使用示例\n\n```\npublic static List<Integer> supply(Integer num, Supplier<Integer> supplier){\n       List<Integer> resultList = new ArrayList<Integer>()   ;\n       for(int x=0;x<num;x++)  \n           resultList.add(supplier.get());\n       return resultList ;\n}\npublic static void main(String[] args) {\n    List<Integer> list = supply(10,() -> (int)(Math.random()*100));\n    list.forEach(System.out::println);\n}\n```\n\n`() -> (int)(Math.random()*100)`  实现Supplier接口的抽象函数\n`supplier.get()` 调用Supplier接口的实现方法。\n\n**3.函数型接口示例**\nFunction接口源码\n\n```\n@FunctionalInterface\npublic interface Function<T, R> {\n\n    /**\n     * Applies this function to the given argument.\n     *\n     * @param t the function argument\n     * @return the function result\n     */\n    R apply(T t);\n\n    ......\n}\n```\n\n转换字符串为Integer\n\n```\npublic static Integer convert(String str, Function<String, Integer> function) {\n    return function.apply(str);\n}\npublic static void main(String[] args) {\n    Integer value = convert(\"28\", x -> Integer.parseInt(x));\n}\n```\n\n**4.断言型接口示例**\nPredicate接口源码\n该接口除了test方法是抽象方法, 其余都是default方法, 该接口可接受一个 lambda表达式, 其实就是实现了test接口的一个匿名类\n\n```\n@FunctionalInterface\npublic interface Predicate<T> {\n\n  //Returns a predicate which evaluates to true only if this predicate\n  //and the provided predicate both evaluate to true.\n  and(Predicate<? super T> p)\n\n  //Returns a predicate which negates the result of this predicate.\n  negate()\n\n  //Returns a predicate which evaluates to true if either\n  //this predicate or the provided predicate evaluates to true\n  or(Predicate<? super T> p)\n\n  //Returns true if the input object matches some criteria\n  test(T t)\n\n  //Returns a predicate that evaluates to true if both or neither\n  //of the component predicates evaluate to true\n  xor(Predicate<? super T> p)\n}\n```\n\n筛选出只有2个字的水果\n\n```\npublic static List<String> filter(List<String> fruit, Predicate<String> predicate){\n    List<String> f = new ArrayList<>();\n    for (String s : fruit) {\n        if(predicate.test(s)){\n            f.add(s);\n        }\n    }\n    return f;\n}\npublic static void main(String[] args) {\n    List<String> fruit = Arrays.asList(\"香蕉\", \"哈密瓜\", \"榴莲\", \"火龙果\", \"水蜜桃\");\n    List<String> newFruit = filter(fruit, (f) -> f.length() == 2);\n    System.out.println(newFruit);\n}\n```\n\n\n### 默认方法\n在Java语言中，一个接口中定义的方法必须由实现类提供实现。但是当接口中加入新的API时， 实现类按照约定也要修改实现，而Java8的API对现有接口也添加了很多方法，比如List接口中添加了sort方法。 如果按照之前的做法，那么所有的实现类都要实现sort方法，JDK的编写者们一定非常抓狂。\n\n幸运的是我们使用了Java8，这一问题将得到很好的解决，在Java8种引入新的机制，支持在接口中声明方法同时提供实现。 这令人激动不已，你有两种方式完成 1.在接口内声明静态方法 2.指定一个默认方法。\n\n我们来看看在JDK8中上述List接口添加方法的问题是如何解决的\n\n```\ndefault void sort(Comparator<? super E> c) {\n    Object[] a = this.toArray();\n    Arrays.sort(a, (Comparator) c);\n    ListIterator<E> i = this.listIterator();\n    for (Object e : a) {\n        i.next();\n        i.set((E) e);\n    }\n}\n```\n\n翻阅List接口的源码，其中加入一个默认方法default void sort(Comparator<? super E> c)。 在返回值之前加入default关键字，有了这个方法我们可以直接调用sort方法进行排序。\n\n```\nList<Integer> list = Arrays.asList(2, 7, 3, 1, 8, 6, 4);\nlist.sort(Comparator.naturalOrder());\nSystem.out.println(list);\n```\n\n### 使用Lambda和Streams\nStream是对集合的包装，通常和lambda一起使用。 使用lambdas可以支持许多操作，如 map, filter, limit, sorted, count, min, max, sum, collect 等等。 同样，Stream使用懒运算，他们并不会真正地读取所有数据，遇到像getFirst() 这样的方法就会结束链式语法。\n\n```\npublic class Person {\n\n    private String firstName, lastName, job, gender;\n\n    private int salary, age;\n\n    public Person(String firstName, String lastName, String job, String gender,\n            int age, int salary) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.gender = gender;\n        this.age = age;\n        this.job = job;\n        this.salary = salary;\n    }\n    // Getter and Setter\n    // . . . . .\n}\n```\n\n接下来，我们将创建两个list,都用来存放Person对象：\n\n```\nList<Person> javaProgrammers = new ArrayList<Person>() {\n    {\n        add(new Person(\"Elsdon\", \"Jaycob\", \"Java programmer\", \"male\",43, 2000));\n        add(new Person(\"Tamsen\", \"Brittany\", \"Java programmer\",\"female\", 23, 1500));\n        add(new Person(\"Floyd\", \"Donny\", \"Java programmer\", \"male\", 33,1800));\n        add(new Person(\"Sindy\", \"Jonie\", \"Java programmer\", \"female\",32, 1600));\n        add(new Person(\"Vere\", \"Hervey\", \"Java programmer\", \"male\", 22,1200));\n        add(new Person(\"Maude\", \"Jaimie\", \"Java programmer\", \"female\",27, 1900));\n        add(new Person(\"Shawn\", \"Randall\", \"Java programmer\", \"male\",30, 2300));\n        add(new Person(\"Jayden\", \"Corrina\", \"Java programmer\", \"female\",35, 1700));\n        add(new Person(\"Palmer\", \"Dene\", \"Java programmer\", \"male\", 33,2000));\n        add(new Person(\"Addison\", \"Pam\", \"Java programmer\", \"female\",34, 1300));\n    }\n};\n\nList<Person> phpProgrammers = new ArrayList<Person>() {\n    {\n        add(new Person(\"Jarrod\", \"Pace\", \"PHP programmer\", \"male\", 34,1550));\n        add(new Person(\"Clarette\", \"Cicely\", \"PHP programmer\", \"female\",23, 1200));\n        add(new Person(\"Victor\", \"Channing\", \"PHP programmer\", \"male\",32, 1600));\n        add(new Person(\"Tori\", \"Sheryl\", \"PHP programmer\", \"female\", 21,1000));\n        add(new Person(\"Osborne\", \"Shad\", \"PHP programmer\", \"male\", 32,1100));\n        add(new Person(\"Rosalind\", \"Layla\", \"PHP programmer\", \"female\",25, 1300));\n        add(new Person(\"Fraser\", \"Hewie\", \"PHP programmer\", \"male\", 36,1100));\n        add(new Person(\"Quinn\", \"Tamara\", \"PHP programmer\", \"female\",21, 1000));\n        add(new Person(\"Alvin\", \"Lance\", \"PHP programmer\", \"male\", 38,1600));\n        add(new Person(\"Evonne\", \"Shari\", \"PHP programmer\", \"female\",40, 1800));\n    }\n};\n```\n\n现在我们使用forEach方法来迭代输出上述列表：\n\n```\nSystem.out.println(\"所有程序员的姓名：\");\njavaProgrammers.forEach((p) -> System.out.printf(\"%s %s;\", p.getFirstName(), p.getLastName()));\nphpProgrammers.forEach((p) -> System.out.printf(\"%s %s;\", p.getFirstName(), p.getLastName()));\n```\n\n我们同样使用forEach方法，增加程序员的工资5%:\n\n```\nSystem.out.println(\"给程序员加薪 5% :\");\nConsumer<Person> giveRaise = e -> e.setSalary(e.getSalary() / 100 * 5 + e.getSalary());\n\njavaProgrammers.forEach(giveRaise);\nphpProgrammers.forEach(giveRaise);\n```\n\n另一个有用的方法是过滤器filter() ,让我们显示月薪超过1400刀的PHP程序员：\n\n```\nSystem.out.println(\"下面是月薪超过 $1,400 的PHP程序员：\") phpProgrammers.stream()\n    .filter((p) -> (p.getSalary() > 1400))\n    .forEach((p) -> System.out.printf(\"%s %s; \", p.getFirstName(), p.getLastName()));\n```\n\n我们也可以定义过滤器，然后重用它们来执行其他操作：\n\n```\n// 定义 filters\nPredicate<Person> ageFilter = (p) -> (p.getAge() > 25);\nPredicate<Person> salaryFilter = (p) -> (p.getSalary() > 1400);\nPredicate<Person> genderFilter = (p) -> (\"female\".equals(p.getGender()));\n\nSystem.out.println(\"下面是年龄大于 24岁且月薪在$1,400以上的女PHP程序员：\");\nphpProgrammers.stream()\n    .filter(ageFilter)\n    .filter(salaryFilter)\n    .filter(genderFilter)\n    .forEach((p) -> System.out.printf(\"%s %s;\", p.getFirstName(), p.getLastName()));\n\n// 重用filters\nSystem.out.println(\"年龄大于 24岁的女性 Java programmers:\");\njavaProgrammers.stream()\n    .filter(ageFilter)\n    .filter(genderFilter)\n    .forEach((p) -> System.out.printf(\"%s %s;\", p.getFirstName(), p.getLastName()));\n```\n\n使用limit方法，可以限制结果集的个数：\n\n```\nSystem.out.println(\"最前面的3个 Java programmers:\");\njavaProgrammers.stream()\n    .limit(3)\n    .forEach((p) -> System.out.printf(\"%s %s;\", p.getFirstName(), p.getLastName()));\n\nSystem.out.println(\"最前面的3个女性 Java programmers:\");\njavaProgrammers.stream()\n    .filter(genderFilter)\n    .limit(3)\n    .forEach((p) -> System.out.printf(\"%s %s;\", p.getFirstName(), p.getLastName()));\n```\n\n将根据名字和薪水排序Java程序员，放到一个list中，然后显示列表：\n\n```\nSystem.out.println(\"根据 name 排序，并显示前5个 Java programmers:\");\nList<Person> sortedJavaProgrammers\n= javaProgrammers.stream()\n    .sorted((p, p2) -> (p.getFirstName().compareTo(p2.getFirstName())))\n    .limit(5)\n    .collect(toList());\n\nsortedJavaProgrammers.forEach((p) -> System.out.printf(\"%s %s; %n\", p.getFirstName(), p.getLastName()));\n\nSystem.out.println(\"根据 salary 排序 Java programmers:\");\nsortedJavaProgrammers= javaProgrammers.stream()\n    .sorted((p, p2) -> (p.getSalary() - p2.getSalary())).collect(toList());\n\nsortedJavaProgrammers.forEach((p) -> System.out.printf(\"%s %s; %n\", p.getFirstName(), p.getLastName()));\n```\n\n如果我们只对最低和最高的薪水感兴趣，比排序后选择第一个/最后一个 更快的是min和max方法：\n\n```\nSystem.out.println(\"工资最低的 Java programmer:\");\nPerson pers = javaProgrammers.stream().min((p1, p2) -> (p1.getSalary() - p2.getSalary())).get();\n\nSystem.out.printf(\"Name: %s %s; Salary: $%,d.\", pers.getFirstName(), pers.getLastName(), pers.getSalary());\n\nSystem.out.println(\"工资最高的 Java programmer:\");\nPerson person = javaProgrammers.stream().max((p, p2) -> (p.getSalary() - p2.getSalary())).get();\n\nSystem.out.printf(\"Name: %s %s; Salary: $%,d.\", person.getFirstName(), person.getLastName(), person.getSalary());\n```\n\n结合 map 方法，我们可以使用 collect 方法来将我们的结果集放到一个字符串，一个 Set 或一个TreeSet中：\n\n```\nSystem.out.println(\"将 PHP programmers 的 first name 拼接成字符串：\");\nString phpDevelopers =\n    phpProgrammers.stream().map(Person::getFirstName).collect(joining(\";\")); // 在进一步的操作中可以作为标记(token)\n\nSystem.out.println(\"将 Java programmers 的 first name 存放到 Set:\");\nSet<String> javaDevFirstName = javaProgrammers.stream().map(Person::getFirstName).collect(toSet());\n\nSystem.out.println(\"将 Java programmers 的 first name 存放到 TreeSet:\");\nTreeSet<String> javaDevLastName = javaProgrammers.stream().map(Person::getLastName).collect(toCollection(TreeSet::new));\n```\n\nStreams 还可以是并行的(parallel)\n\n```\nSystem.out.println(\"计算付给 Java programmers 的所有money:\");\nint totalSalary = javaProgrammers\n    .parallelStream()\n    .mapToInt(p -> p.getSalary())\n    .sum();\n```\n\n我们可以使用summaryStatistics方法获得stream 中元素的各种汇总数据。 接下来，我们可以访问这些方法，比如getMax, getMin, getSum或getAverage:\n\n```\n//计算 count, min, max, sum, and average for numbers\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nIntSummaryStatistics stats = numbers\n    .stream()\n    .mapToInt((x) -> x)\n    .summaryStatistics();\n\nSystem.out.println(\"List中最大的数字 : \" + stats.getMax());\nSystem.out.println(\"List中最小的数字 : \" + stats.getMin());\nSystem.out.println(\"所有数字的总和 : \" + stats.getSum());\nSystem.out.println(\"所有数字的平均值 : \" + stats.getAverage());\n```\n","tags":["java"]}]